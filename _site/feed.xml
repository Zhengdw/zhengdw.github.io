<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-12T16:02:57-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Da Wei (David) Zheng</title><subtitle>PhD student studying theoretical computer science  at the University of Illinois at Urbana-Champaign (UIUC). I solve problems for fun.</subtitle><entry><title type="html">[SekaiCTF 2022] Diffecient</title><link href="http://localhost:4000/2022/10/03/sekaictf-diffecient.html" rel="alternate" type="text/html" title="[SekaiCTF 2022] Diffecient" /><published>2022-10-03T00:00:00-05:00</published><updated>2022-10-03T00:00:00-05:00</updated><id>http://localhost:4000/2022/10/03/sekaictf-diffecient</id><content type="html" xml:base="http://localhost:4000/2022/10/03/sekaictf-diffecient.html"><![CDATA[<h1 id="sekaictf-2022-diffecient">[SekaiCTF 2022] Diffecient</h1>

<h2 id="tldr">tl;dr</h2>

<p>Find a hash collision for a bloom filter using <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash3</a> aka mmh3.
I got first blood on the challenge by being too lazy to do cryptanalysis and instead using the powers of OSINT to find an existing solutions coded by real cryptographers.</p>

<h2 id="description">Description</h2>

<p>crypto/Diffecient; 7 solves, 498 points</p>

<p>Challenge author: <code class="language-plaintext highlighter-rouge">deut-erium</code></p>

<p>Welcome to the Diffecient Security Key Database API, for securely and efficiently saving tons of long security keys! Feel free to query your security keys, and pay a little to add your own to our state-of-the-art database.</p>

<p>We trust our product so much that we even save our own keys here!</p>

<p>Source code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">mmh3</span>

<span class="k">def</span> <span class="nf">randbytes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="nb">bytes</span> <span class="p">([</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>

<span class="k">class</span> <span class="nc">BloomFilter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__digests</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span> <span class="o">=</span> <span class="n">hash_func</span>

    <span class="k">def</span> <span class="nf">security</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">false_positive</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">.</span><span class="n">__k</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">__i</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">__m</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">__k</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">false_positive</span><span class="p">).</span><span class="n">bit_length</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="nb">ZeroDivisionError</span><span class="p">,</span> <span class="nb">OverflowError</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">__k</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">__digests</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">__m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">__m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">__digests</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">__k</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">num_passwords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">__i</span>

    <span class="k">def</span> <span class="nf">memory_consumption</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">__digests</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PasswordDB</span><span class="p">(</span><span class="n">BloomFilter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">security</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">add_keys</span><span class="p">(</span><span class="n">security</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">addition_quota</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">added_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh_security</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">security</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">thresh_security</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Added {} security keys to DB"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_passwords</span><span class="p">()))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Original size of keys {} KB vs {} KB in DB"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">num_passwords</span><span class="p">()</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">memory_consumption</span><span class="p">()</span><span class="o">//</span><span class="mi">1024</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">check_admin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">".{32,}"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should be atleast 32 characters long"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[a-z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 lowercase character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[A-Z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 uppercase character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\d)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 digit character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\W)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 special character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">added_keys</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin account restricted for free tier"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">check</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">check</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Key present in DB"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Key not present in DB"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">addition_quota</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">added_keys</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">addition_quota</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"key added successfully to DB"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"API quota exceeded"</span><span class="p">)</span>


<span class="n">BANNER</span> <span class="o">=</span> <span class="sa">r</span><span class="s">"""
 ____  ____  ____  ____  ____  ___  ____  ____  _  _  ____
(  _ \(_  _)( ___)( ___)( ___)/ __)(_  _)( ___)( \( )(_  _)
 )(_) )_)(_  )__)  )__)  )__)( (__  _)(_  )__)  )  (   )(
(____/(____)(__)  (__)  (____)\___)(____)(____)(_)\_) (__)

Welcome to diffecient security key database API for securely
and efficiently saving tonnes of long security keys!
Feel FREE to query your security keys and pay a little to
add your own security keys to our state of the art DB!
We trust our product so much that we even save our own keys here
"""</span>
<span class="k">print</span><span class="p">(</span><span class="n">BANNER</span><span class="p">)</span>
<span class="n">PASSWORD_DB</span> <span class="o">=</span> <span class="n">PasswordDB</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">)</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">option</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">"Enter API option:</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">"Enter key in hex</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
            <span class="n">PASSWORD_DB</span><span class="p">.</span><span class="n">query_db</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">"Enter key in hex</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
            <span class="n">PASSWORD_DB</span><span class="p">.</span><span class="n">add_sample</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">"Enter key in hex</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">PASSWORD_DB</span><span class="p">.</span><span class="n">check_admin</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">flag</span> <span class="kn">import</span> <span class="n">flag</span>
                <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"No Admin no flag"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something wrong happened"</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="first-impressions-of-the-problem">First impressions of the problem</h2>

<p>We’re given a bunch of code that implements a password database that stores passwords
using <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash3</a> in a <a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a>.
The exact way insertions into the bloom filter is done is with:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">__k</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">__digests</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">__m</span><span class="p">)</span>
</code></pre></div></div>
<p>The bloom filter calls MurmurHash3 47 times with the second parameter being the seed (in this case the seeds are 0 to 46).</p>

<p>We’re allowed to add exactly one thing to the bloom filter.
We can also check if a password is in the bloom filter, if it is, we get the flag!
However, we need to make sure we pass the <code class="language-plaintext highlighter-rouge">check_admin</code> function to do so:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">check_admin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">".{32,}"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should be atleast 32 characters long"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[a-z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 lowercase character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[A-Z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 uppercase character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\d)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 digit character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\W)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 special character"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">added_keys</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Admin account restricted for free tier"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">check</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">check_admin</code> function ensures the password is 32 characters long, and contains some characters, and 
that we didn’t add the key ourself. 
Due to the nature of the hashing usages,
if we add a password and find another password hashing to the same value (aka a hash collision),
we wouldn’t have added the key ourselves, and it would be “in the database” according to the
bloom filter. So our goal from now is to just find a hash collisions for the first 47 hashes in the bloom filter.</p>

<h2 id="playing-with-hash-collisions">Playing with hash collisions</h2>

<p>The first thing we can do is play around with hashes to see if we can find a simple hash collision in the bloom filter.</p>

<p>Very quickly, after playing around with some zero bytes, I find one:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">mmh3</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">check_admin</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">".{32,}"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should be atleast 32 characters long"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[a-z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 lowercase character"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">b</span><span class="s">"(?=.*[A-Z])"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 uppercase character"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\d)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 digit character"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">br</span><span class="s">"(?=.*\W)"</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Admin key should contain atleast 1 special character"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="s">'0000'</span>
<span class="n">b</span> <span class="o">=</span> <span class="s">'000000'</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">):</span>
    <span class="n">S</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">i</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">):</span>
    <span class="n">S</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">i</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">check_admin</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">check_admin</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
</code></pre></div></div>

<p>The hashes aren’t actually colliding for the same seeds, but are colliding at different seeds in a way that somehow works.
Unfortunately, this doesn’t really help, both passwords clearly fails <code class="language-plaintext highlighter-rouge">check_admin</code>  for obvious reasons.
Furthermore, it isn’t clear how we can extend this collision into a longer and fulfil all the conditions of length and character content.</p>

<p>Back to the drawing board, I decided to do some OSINT.</p>

<h2 id="osint-about-hash-collisions">OSINT about hash collisions</h2>

<p>The best place to start any search is on Wikipedia, 
so I begin with the <a href="https://en.wikipedia.org/wiki/MurmurHash">Wikipedia page on MurmurHash</a>.
Reading through, I notice a section on <a href="https://en.wikipedia.org/wiki/MurmurHash#Vulnerabilities">Vulnerabilities of MurmurHash</a>.
The page mentions a collision attack found by two cryptographers Jean-Philippe Aumasson and Daniel J. Bernstein
where even randomized seeds were vulnerable. This is great, since if it works for random seeds, it basically means that it would work for “most” seeds, including the seeds from 0 to 46.</p>

<p>The wikipedia lists a single citation to <a href="https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">a blog by Martin Boßlet from 2012</a> 
where he provides a ruby script, and lists some hash collisions.
Unfortunately, its for MurmurHash2, which is different, and his collisions don’t work for MurmurHash3. 
The blog said similar techniques are possible, but I don’t feel like (or really know how to) perform cryptanalysis to do something similar.</p>

<p>We’re not completely out of luck as the blog mentions results Aumasson and Bernstein “completely breaking” MurmurHash3 by finding multicollision hashes and providing implementations of it at the following URL: <a href="https://131002.net/siphash/#at">https://131002.net/siphash/#at</a>. Following the URL unfortuantely redirects to the <a href="https://www.aumasson.jp/#at">homepage of JP Aumasson</a>, and clicking the SipHash link on his homepage just goes to the Wikipedia page for SipHash. 
It seemed like Aumasson must have reorganized his web pages, so we’re out of luck here.</p>

<p>Or are we? Good thing the <a href="https://archive.org/web/">Internet Archive</a> exists, we’ll just use the Wayback Machine to travel back in time before he reorganized his web page (assuming the page at some point got a lot of traffic).
Fortunately for us it got <a href="https://web.archive.org/web/20180401000000*/131002.net/siphash">lots of traffic in 2018</a> and sporadically in other years. On the website he provides some <a href="https://web.archive.org/web/20180901061338/https://131002.net/siphash/murmur3collisions-20120827.tar.gz">C++ code to find universal (key-independent) hash collisions</a>, which is exactly what I want.</p>

<p>After downloading and untarring, I inspected the source code and am greeted with the following comment:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * multicollisions for MurmurHash3
 *
 * MurmurHash3 C++ implementation is available at 
 * http://code.google.com/p/smhasher/wiki/MurmurHash3
 *
 * the function Murmur3Multicollisions finds many different inputs
 * hashing to the same 32-bit value (multicollision)
 * 
 * example output:
 * 32-bit seed 7a0e823a
 * 4-multicollision
 * 16-byte inputs
 * MurmurHash3_x86_32( bdd0c04b5c3995827482773b12acab35 ) = 94d7cf1b
 * MurmurHash3_x86_32( 652fa0565c3946be7482773b12acab35 ) = 94d7cf1b
 * MurmurHash3_x86_32( bdd0c04b5c399582cc23983012ac5c71 ) = 94d7cf1b
 * MurmurHash3_x86_32( 652fa0565c3946becc23983012ac5c71 ) = 94d7cf1b
 *
 * the multicollisions found are "universal": they work for any seed/key
 *
 * authors:
 * Jean-Philippe Aumasson, Daniel J. Bernstein
 */</span>
</code></pre></div></div>

<p>Huh, so they provide some example 16-byte input that cause hash collisions. However we need 32-byte collisions.
The natural next step was to look through the code to try to see if I can easily change some parameter in their code to change it to 32-byte collisions (it looks like it would be trivial to, but I never even bothered running their code). 
Instead I figure I’d try to see if the 16-byte collisions they found extended to 32-byte ones, by just doubling them (adding a copy of themselves to the end).
This might be a strange thing to try, but these sorts of hashes that shift bits around are usually very amenable to
length extension type attacks, so it seemed to be a reasonable thing to try.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="s">'bdd0c04b5c3995827482773b12acab35'</span>
<span class="n">b</span> <span class="o">=</span> <span class="s">'652fa0565c3946be7482773b12acab35'</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">a</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">+</span><span class="n">b</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">):</span>
    <span class="n">S</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">i</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">47</span><span class="p">):</span>
    <span class="n">S</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mmh3</span><span class="p">.</span><span class="nb">hash</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">i</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">check_admin</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">check_admin</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
</code></pre></div></div>

<p>The output was:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bdd0c04b5c3995827482773b12acab35bdd0c04b5c3995827482773b12acab35
652fa0565c3946be7482773b12acab35652fa0565c3946be7482773b12acab35
47
True
True
</code></pre></div></div>

<p>Wow, it just worked somehow! 
It consisted of some random bytes, so it’s not surprising it passed all the other checks,
but the fact that it hashes to the same values is surprising.
So I just plugged it into the program and out popped the flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 ____  ____  ____  ____  ____  ___  ____  ____  _  _  ____
(  _ \(_  _)( ___)( ___)( ___)/ __)(_  _)( ___)( \( )(_  _)
 )(_) )_)(_  )__)  )__)  )__)( (__  _)(_  )__)  )  (   )(
(____/(____)(__)  (__)  (____)\___)(____)(____)(_)\_) (__)

Welcome to diffecient security key database API for securely
and efficiently saving tonnes of long security keys!
Feel FREE to query your security keys and pay a little to
add your own security keys to our state of the art DB!
We trust our product so much that we even save our own keys here

Added 1102 security keys to DB
Original size of keys 275 KB vs 202 KB in DB
Enter API option:
2
Enter key in hex
bdd0c04b5c3995827482773b12acab35bdd0c04b5c3995827482773b12acab35
key added successfully to DB
Enter API option:
3                                                               
Enter key in hex
652fa0565c3946be7482773b12acab35652fa0565c3946be7482773b12acab35
b'SEKAI{56f066a1b13fd350ac4a4889efe22cb1825651843e9d0ccae0f87844d1d65190}'
</code></pre></div></div>

<p>Neato, I solved (and in fact got first blood) on a cryptography challenge without doing any of my own cryptanalysis, writing any real code, or even running any real code.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[[SekaiCTF 2022] Diffecient]]></summary></entry><entry><title type="html">[UTCTF 2022] Sunset</title><link href="http://localhost:4000/2022/03/13/utctf-sunset.html" rel="alternate" type="text/html" title="[UTCTF 2022] Sunset" /><published>2022-03-13T00:00:00-06:00</published><updated>2022-03-13T00:00:00-06:00</updated><id>http://localhost:4000/2022/03/13/utctf-sunset</id><content type="html" xml:base="http://localhost:4000/2022/03/13/utctf-sunset.html"><![CDATA[<h1 id="utctf-2021-sunset">[UTCTF 2021] Sunset</h1>

<h2 id="tldr">tl;dr</h2>

<p>Break a <strong>scheme for generating a shared secret</strong> with a cryptosystem relating to some sort of
<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform">discrete fourier transform (DFT)</a>.
The solution described here involves <strong>NOT</strong> reversing the values of the keys as probably intended
(which can be done by some linear algebra),
but instead exploits the some of <strong>group properties</strong> of a cyclic array under convolution modulo a prime.</p>

<h2 id="description">Description</h2>

<p>cryptography/Sunset; 15 solves, 996 points</p>

<p>Challenge author: <code class="language-plaintext highlighter-rouge">oops</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subset sumset what did i do Wrap the value of key with utflag{} for the flag.
</code></pre></div></div>

<p>Files: <code class="language-plaintext highlighter-rouge">main.py</code> and <code class="language-plaintext highlighter-rouge">output.txt</code></p>

<h2 id="the-writeup">The writeup</h2>

<p>See writeup I wrote at <a href="https://ubcctf.github.io/2022/03/utctf-sunset/">https://ubcctf.github.io/2022/03/utctf-sunset/</a>.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[[UTCTF 2021] Sunset]]></summary></entry><entry><title type="html">[K3RN3L CTF 2021] BogoAttack</title><link href="http://localhost:4000/2021/11/14/k3rn3lctf-bogo-attack.html" rel="alternate" type="text/html" title="[K3RN3L CTF 2021] BogoAttack" /><published>2021-11-14T00:00:00-06:00</published><updated>2021-11-14T00:00:00-06:00</updated><id>http://localhost:4000/2021/11/14/k3rn3lctf-bogo-attack</id><content type="html" xml:base="http://localhost:4000/2021/11/14/k3rn3lctf-bogo-attack.html"><![CDATA[<h1 id="k3rn3l-ctf-2021-bogoattack">[K3RN3L CTF 2021] BogoAttack</h1>

<h2 id="tldr">tl;dr</h2>

<p>Find the order of a permutation of size \(10^4\) stored in an array
with an oracle that is able to get the contents
of a subset of indices of the array but randomly shuffles the contents before returning.
There is a limit of \(15\) queries.
Solve by a divide and conquer/parallel binary search algorithm.</p>

<h2 id="description">Description</h2>

<p>misc/BogoAttack; 26 solves, 446 points</p>

<p>Challenge author: <code class="language-plaintext highlighter-rouge">DrDoctor</code></p>

<p>Someone attacced by Bogo! I must seek revenge. Now is the time to attacc back!</p>

<p><a href="https://flu.xxx/static/chall/lwsr_0c872acfc0b66f185a4968ac3198e067.zi://ctf.k3rn3l4rmy.com/kernelctf-distribution-challs/bogo-attack/main.py">main.py</a></p>

<h2 id="first-impressions-of-the-problem">First impressions of the problem</h2>

<p>This problem was actually first given as <code class="language-plaintext highlighter-rouge">Bogo Solve</code> where the query limit was
accidentally not enforced. 
I didn’t notice and solved this problem (and later only modified the port
of the server in my solve script). 
I’ll walk through my first thoughts on the problem assuming the limit was
actually enforced.</p>

<p>We’re given the following python script that’s running on the server:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="n">NUMS</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">NUMS</span><span class="p">)</span>
<span class="n">tries</span> <span class="o">=</span> <span class="mi">15</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">'Enter (1) to steal and (2) to guess: '</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tries</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'You ran out of tries. Bye!'</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">(</span><span class="s">'Enter numbers to steal: '</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">))</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">assert</span> <span class="mi">0</span><span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">NUMS</span><span class="p">)</span>
                <span class="n">output</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">NUMS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Stolen:'</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
            <span class="n">tries</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">(</span><span class="s">'What is the list: '</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">NUMS</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">).</span><span class="n">read</span><span class="p">())</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'NOPE'</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Not a choice.'</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Error. Nice Try...'</span><span class="p">)</span>
</code></pre></div></div>

<p>I got pretty excited when I saw the question, as a former competitive programmer (or maybe I still am one?) and a computer science theory student.
(So excited that I probably spent ten times longer writing this writeup than 
actually solving and coding a solution.)
I immediately recognize this as an interactive competitive programming question. 
(This might have seen this exact one on <a href="https://codeforces.com/">Codeforces</a> or
<a href="https://atcoder.jp/">AtCoder</a> but interactive problems are pretty rare, and my memory is fuzzy)
The question can be summarized as follows:</p>

<blockquote>
  <p>Given a permutation of size \(10^4\) in an array and access to the array
via an oracle 
that is able to get the contents of a subset of indices of the array 
but randomly shuffles the contents before returning.
Find the contents in at most \(15\) queries.</p>
</blockquote>

<p>First we note that \(15\) is more or less \(\log_2(10^4)\),
 so we want to make logarithmically many queries. 
This suggests some sort of divide and conquer solution.
But what exactly are we dividing here?</p>

<h2 id="a-divide-and-conquer-approach">A Divide and Conquer approach</h2>

<p>Let’s think about what we can accomplish with one query.
We can split the array down the middle and query all the indices
in the first half as pictured below. What does this give us?</p>

<p><img src="/assets/images/k3rn3lctf2021/bogoattack/DC1.png" alt="dc1" /></p>

<p>The server would tell us which elements are in the first half,
which (by simple deduction) would tell us the rest of the elements
are in the second half.
Now we can treat these two halves of the array as two seperate problems
in and of themselves and do the same thing.</p>

<p><img src="/assets/images/k3rn3lctf2021/bogoattack/DC2.png" alt="dc2" /></p>

<p>For each of these subproblems we can repeat again, and 
continue until we know exactly where every element is!</p>

<p><img src="/assets/images/k3rn3lctf2021/bogoattack/DC3.png" alt="dc3" /></p>

<p>However, naively this would give us a lot of queries,
in particular, if we let \(Q(n)\) denote the number of queries
needed to solve the problem on an array of size \(n\), 
we essentially found the following recurrence:</p>

\[Q(n) = 2 Q(n/2) + 1\]

<p>Unfortuantely this solves to \(Q(n) = n\), which is no better than
querying each position individually!
We need one more idea to help us out.
What if we send the queries for all our subproblems of the 
same size simultaneously?</p>

<p>Since the elements involved in each subproblem form a partition of our
original elements, it doesn’t matter that we get the elements in a random order,
we already <strong>know</strong> which elements are from each subproblem.
This means we can solve the problem with the recurrence of:</p>

\[Q(n) = Q(n/2) + 1  = \lfloor \log_2 n \rfloor\]

<p>However, coding a solution like this seems complicated, how do we maintain
all these subproblems?</p>

<h2 id="another-way-of-looking-at-things">Another way of looking at things</h2>

<p>Let’s take a step back and look at what we’re learning from each we make.
For simplicity, let’s actually assume that we are working with a permutation
of size \(2^{14}\) elements (\(16384\))
instead of \(10^4\) elements. We’ll see why this makes things easier in a bit.</p>

<p>Let’s look at the first query to a problem:</p>

<p><img src="/assets/images/k3rn3lctf2021/bogoattack/DC1.png" alt="dc1" /></p>

<p>Querying for which elements are in the first half of the array is 
essentially looking at what elements have the index of the first bit
be \(0\). The rest of the numbers have first bit \(1\).
So a query can learn the most significant bit of the <strong>positions</strong> of all the numbers 
in the list!</p>

<p>In fact, there was nothing special about chooosing the first half,
the positions with most siginficant bit \(0\).
We could just as easily
have chosen every position with a \(0\) in the \(k\)th bit for some \(1\le k \le 14\)
and learn that bit for every element in the permutation!</p>

<p>So this suggests another algorithm, for each bit, learn the \(k\)th bit of 
every element for every \(k\).
If you examine this new algorithm closely, this would make the same queries
as the divide and conquer algorithm we had before!</p>

<p>This is a fairly common phenomenon, when doing binary divide and conquer,
we can instead view it in terms of the bits of the number and work with those for a
much simpler to code algorithm 
(this forms the basis of things like <a href="https://codeforces.com/blog/entry/18051">segment trees</a>).</p>

<p>We can view this as a form of parallel binary search, for every element of
the permutation, we are finding
its position in the list via binary search.
Cleverly, we’re able to do this for all 
elements at once!</p>

<p>This is what I ended up coding:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">read_until</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="sa">b</span><span class="s">'='</span><span class="p">):</span>
    <span class="n">delim</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">delim</span><span class="p">,</span> <span class="s">"ascii"</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">buf</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">delim</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[+] READING: "</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buf</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="s">"ctf.k3rn3l4rmy.com"</span><span class="p">,</span> <span class="mi">2247</span><span class="p">)</span>


<span class="n">NUMS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="n">POS</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">):</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">'['</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">']'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">', '</span><span class="p">)</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">POS</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">NUMS</span><span class="p">[</span><span class="n">POS</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">output</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">NUMS</span><span class="p">:</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span>
<span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'2'</span><span class="p">)</span>
<span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sock</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[[K3RN3L CTF 2021] BogoAttack]]></summary></entry><entry><title type="html">[Hack.lu 2021] lwsr</title><link href="http://localhost:4000/2021/10/31/hacklu-lwsr.html" rel="alternate" type="text/html" title="[Hack.lu 2021] lwsr" /><published>2021-10-31T00:00:00-05:00</published><updated>2021-10-31T00:00:00-05:00</updated><id>http://localhost:4000/2021/10/31/hacklu-lwsr</id><content type="html" xml:base="http://localhost:4000/2021/10/31/hacklu-lwsr.html"><![CDATA[<h1 id="hacklu-ctf-2021">[Hack.lu CTF 2021]</h1>

<h2 id="tldr">tl;dr</h2>

<p>Break a cryptosystem using the <a href="https://en.wikipedia.org/wiki/Learning_with_errors">learning with errors (LWE)</a> problem and a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">linear-feedback shift register (LFSR)</a> by using the fact that the server leaks a bit.</p>

<h2 id="description">Description</h2>

<p>crypto/lwsr; 20 solves, 285 points</p>

<p>Challenge author: <code class="language-plaintext highlighter-rouge">midao</code></p>

<p>Sometimes you learn with errors, but I recently decided to learn with shift registers. Or did I learn with errors over shift registers? Shift registers over errors? Anyway, you may try to shift upwards on the investors board with this.</p>

<p>nc flu.xxx 20075</p>

<p><a href="https://flu.xxx/static/chall/lwsr_0c872acfc0b66f185a4968ac3198e067.zip">zip file</a></p>

<h2 id="ingredients-of-the-cryptosystem">Ingredients of the cryptosystem</h2>

<p>Looking through the code there are two pieces of a cryptosystem that were new to me (so I decided to write this blog on it).
The first is a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">linear-feedback shift register (LFSR)</a> with a 384-bit <code class="language-plaintext highlighter-rouge">state</code>, after using the state
it updates it with <code class="language-plaintext highlighter-rouge">state = lfsr(state)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lfsr</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="c1"># x^384 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x + 1
</span>    <span class="n">mask</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">384</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">377</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">newbit</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">).</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">newbit</span> <span class="o">&lt;&lt;</span> <span class="mi">383</span><span class="p">)</span>
</code></pre></div></div>

<p>Essentially, it generates a bit stream by xoring some bits in the stream to generate the next bit (in this case the last 7 bits and the 384th bit).</p>

<p>The other piece new to me is <a href="https://en.wikipedia.org/wiki/Learning_with_errors">learning with errors (LWE)</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n = 128
m = 384

lwe = Regev(n)
q   = lwe.K.order()
pk  = [list(lwe()) for _ in range(m)] 
sk  = lwe._LWE__s 
</code></pre></div></div>

<p>This generates a secret vector \(s\), and a list of \(m\) public key values consisting of a \(n\) dimensional vector \(v_i\) and a value \(c_i\) where the dot product \(s \cdot v_i \approx c_i\). For these sage commands, we are working in \(\mathbb{F}^n_q\) for \(q = 16411\), and approximately equal means some small error according to a discrete gaussian distribution.</p>

<p>Both LWE and LFSR have uses in cryptography.
LFSRs are generate a stream cipher with the right distribution of bits in the output, and can have very long cycles, and is simple to implement (even in hardware) however there are serious flaws with its security.
LWEs is a hard problem that can be the basis of a cryptosystem.</p>

<h2 id="cryptanalysis">Cryptanalysis</h2>

<p>Looking at the code that does the encryption:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">flag</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">format</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="s">'#010b'</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]):</span>
        <span class="c1"># encode message
</span>        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bit</span>
        <span class="k">assert</span> <span class="n">msg</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">msg</span> <span class="o">==</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># encrypt
</span>        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]),</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vector</span><span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># fix ciphertext
</span>        <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">msg</span>
        <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># advance LFSR
</span>        <span class="n">state</span> <span class="o">=</span> <span class="n">lfsr</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</code></pre></div></div>

<p>The code encrypts each bit of the string by computing \(v = \sum_{i\in L} v_i\) where \(L\) are the on bits in the LFSR and computing the corresponding approximate \(c = \sum_{c_i\in L} c_i\), and adding <code class="language-plaintext highlighter-rouge">q &gt;&gt; 1</code> in \(\mathbb{F}_q\) if the bit is on. 
Note that \(c\) is approximate, but the sum of a gaussian distribution is still a gaussian distribution with a wider distribution, so it is still approximately correct.</p>

<p>Afterwards, the server let’s us encode our own messages bit by bit, and checks if it is correct.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c1"># now it's your turn :)
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Your message bit: "</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">assert</span> <span class="n">msg</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">msg</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># encode message
</span>    <span class="n">pk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">msg</span>

    <span class="c1"># encrypt
</span>    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]),</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vector</span><span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># fix public key
</span>    <span class="n">pk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">msg</span>

    <span class="c1"># check correctness by decrypting
</span>    <span class="n">decrypt</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dot_product</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">decrypt</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">decrypt</span> <span class="o">-=</span> <span class="n">q</span>
    <span class="n">decode</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">decrypt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">decode</span> <span class="o">==</span> <span class="n">msg</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Oh no :("</span><span class="p">)</span>

    <span class="c1"># advance LFSR
</span>    <span class="n">state</span> <span class="o">=</span> <span class="n">lfsr</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</code></pre></div></div>

<p>This seems fine, and in fact some local testing shows that decryption should work with very high probability, as the error for the sum of bits should be rather small.
On closer inspection however, this second encryption is not implemented properly, instead
of the ciphertext being modified when the bit is on, the value of the first vector is modified by <code class="language-plaintext highlighter-rouge">pk[0][1] += (q &gt;&gt; 1) * msg</code>. Meaning, if the first bit of the LFSR is a 0, but the encrypted message is a 1, there WILL be an error!</p>

<p>This means, by asking the server to encrypt a 1, the output of the server will leak the 0th bit of the LFSR. Since the LFSR shifts all the bits each time, if we query the server 384 times, we will recover all the bits of the LFSR.</p>

<p>However, recovering the LFSR is not enough, since it changes every time, we need to be able to recover the previous state of the LFSR.
Fortunately by looking at the equation of the last bit, we can easily recover the first bit we lost in the shift, so the LFSR is performing an invertible operation.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">revlfsr</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">mask</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">384</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">376</span><span class="p">)</span> 
    <span class="n">newbit</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">).</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">newbit</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">384</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>And now we’re done! We know the full state of the LFSR, so if we try encrypting using the same scheme, if the value we compute by summing the corresponding values \(c_i\) in the public key is exactly equal, than we know that bit is 0, otherwise, we should be off by exactly <code class="language-plaintext highlighter-rouge">q &gt;&gt; 1</code>(\(8205\)), so we are done without having to deal with any vector operations at all!</p>

<p>Doing this gives us the flag!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag{your_fluxmarket_stock_may_shift_up_now}
</code></pre></div></div>

<p>Note that there were other linear algebra solutions based on the structure of the LFSR, including those that didn’t need to send ANY queries to the server. This is because we have an exact sum of vectors, so we can solve directly for the internal state of the LFSR.
On the other hand my solution didn’t even look at a single vector!</p>

<p>Full solve script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sage.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">read_until</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="sa">b</span><span class="s">'='</span><span class="p">):</span>
    <span class="n">delim</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">delim</span><span class="p">,</span> <span class="s">"ascii"</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">buf</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">delim</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[+] READING: "</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buf</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="s">"flu.xxx"</span><span class="p">,</span> <span class="mi">20075</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lfsr</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="c1"># x^384 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x + 1
</span>    <span class="n">mask</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">384</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">377</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">newbit</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">).</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">newbit</span> <span class="o">&lt;&lt;</span> <span class="mi">383</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">revlfsr</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">mask</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">384</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">376</span><span class="p">)</span> 
    <span class="n">newbit</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">).</span><span class="n">count</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">newbit</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">384</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">384</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">16411</span>

<span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span> <span class="c1"># first line saying something about q
</span><span class="k">exec</span><span class="p">(</span><span class="sa">b</span><span class="s">'pk = '</span> <span class="o">+</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">).</span><span class="n">strip</span><span class="p">())</span>

<span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span> <span class="c1"># some nonsense that doesn't matter
</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">read_colon</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">inp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="sa">b</span><span class="s">':'</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">exec</span><span class="p">(</span><span class="sa">b</span><span class="s">'c.append('</span><span class="o">+</span><span class="n">l</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span><span class="o">+</span><span class="sa">b</span><span class="s">')'</span><span class="p">)</span>

<span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">384</span><span class="p">):</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span> <span class="c1"># end of : line
</span>    <span class="k">if</span> <span class="sa">b</span><span class="s">'Oh no'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># end of : line, because we read to the first colon of :(
</span>        <span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span> 

<span class="c1"># unwind the "cleared" LFSR bits
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">384</span><span class="p">):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">revlfsr</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

<span class="c1"># unwind all the used LFSR bits
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">revlfsr</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

<span class="n">ans</span> <span class="o">=</span> <span class="s">""</span>
<span class="n">cum</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">true_val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">((</span><span class="n">state</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pk</span><span class="p">)])</span><span class="o">%</span><span class="n">q</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">true_val</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">q</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">-=</span> <span class="n">q</span>
    <span class="n">cum</span> <span class="o">+=</span> <span class="s">"0"</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="s">"1"</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cum</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">8</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">+=</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cum</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">cum</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">lfsr</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[[Hack.lu CTF 2021]]]></summary></entry><entry><title type="html">[DUCTF 2021] yadlp</title><link href="http://localhost:4000/2021/09/27/ductf-yadlp.html" rel="alternate" type="text/html" title="[DUCTF 2021] yadlp" /><published>2021-09-27T00:00:00-05:00</published><updated>2021-09-27T00:00:00-05:00</updated><id>http://localhost:4000/2021/09/27/ductf-yadlp</id><content type="html" xml:base="http://localhost:4000/2021/09/27/ductf-yadlp.html"><![CDATA[<h1 id="ductf-2021-yadlp">[DUCTF 2021] yadlp</h1>

<h2 id="tldr">tl;dr</h2>

<p>Solve the discrete log problem on a funny looking group described by points on a hyperbolic
curve, then solve the modular knapsack problem for the flag.</p>

<h2 id="description">Description</h2>

<p>crypto/yadlp; 14 solves, 494 points</p>

<p>Challenge author: <code class="language-plaintext highlighter-rouge">joseph#8210</code></p>

<p>Yet another discrete logarithm problem challenge…</p>

<p><a href="https://play.duc.tf/files/85c7911a3127752c188b8839b7edaeeb/yadlp.sage">yadlp.sage</a>
<a href="https://play.duc.tf/files/bdfdc35ee7c0ada2987a3a40b53d897a/output.txt">output.txt</a></p>

<h2 id="solving-the-problem">Solving the problem</h2>

<p>I started by looking at the files, and saw some familiar looking group operations
that looked like elliptic-curve cryptography (ECC).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">G_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">B</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span> <span class="o">+</span> <span class="n">D</span><span class="o">*</span><span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span> <span class="o">+</span> <span class="n">x2</span><span class="o">*</span><span class="n">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">G_mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">G_add</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">G_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">get_elem</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kronecker</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="n">d</span><span class="p">)))</span> <span class="o">*</span> <span class="n">inverse_mod</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>The flag was encoded by splitting the 48 byte input into 6 segments of 8 bytes long, and
summed them together with the group operation. 
We need to first solve the discrete log problem to recover the coefficients of the summands,
then somehow recover the summands.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FLAG</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">).</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">FLAG</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span>
<span class="n">M</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">FLAG</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">FLAG</span><span class="p">),</span> <span class="mi">8</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">FLAG</span> <span class="o">=</span> <span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">M</span> <span class="o">=</span> <span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="n">G</span> <span class="o">=</span> <span class="p">[</span><span class="n">rand_element</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">M</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">gi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">G_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">G_mul</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="solving-the-discrete-log-problem">Solving the discrete log problem</h3>

<p>I thought it was ECC but on closer inspection, the <code class="language-plaintext highlighter-rouge">get_element</code> function looks a little funny.
The equation suggests that we’re working with some curve where \(y\) satisfies
the equation (over \(\mathbb{Z}_p\)):</p>

\[y =\frac{1}{D}(x + \sqrt{(D+1)x^2  - D})\]

<p>Simplifying and rearanging we get</p>

\[Dy^2 - 2xy -x^2 + 1 = 0\]

<p>This is not an elliptic curve, this is a hyperbola! I had no idea that you could define
a group structure over hyperbolas of this form, so as a sanity check, I 
wrote a short function to check that all operations done in the encoding were on the curve.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">on_curve</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">D</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> <span class="o">==</span><span class="mi">0</span>
</code></pre></div></div>

<p>Furthermore, \((1, 0)\) seemed to be the identity element.
All the points were on the curve so all signs pointed towards this being some funny 
group operation.
Since this challenge was called yadlp, I assumed we needed to take discrete logs
in this group. Hopefully the group order would be relatively nice to take discrete logs.
However I had no idea what the order of group even was!</p>

<p>I couldn’t get much further from staring at this curve and group law, so I 
started putting search terms in google like “hyperbolic curve encryption”. 
After some digging around I found <a href="https://doi.org/10.2991/icmt-13.2013.26">this obscure paper</a>
where they propose a cryptosystem based on Pell’s equations (\(x^2 - Dy^2 = 1\)) with a 
very similar looking group addition operation to what was in the code.</p>

<p>Notably, they claim that if \(p\equiv 3\pmod 4\), then the group order would be \(p+1\), 
which our prime is. I verified quickly that \((p+1)G = (1,0)\) for any group element \(G\)
I tested, so I could reasonably believe that this was the group order.</p>

<p>Throwing \(p+1\) into factordb gave a very nice looking factorization with small primes.
(I learned afterwards this is called a smooth number, specifically a \(2^{32}\)-smooth number.)</p>

\[\begin{align*}  p+1 
= 2^4 &amp;\cdot 3^3 \cdot 3271 \cdot 18119 \cdot 23857 \cdot 35923 \cdot 1505323 \cdot 3036643 \cdot 3878597 \cdot 7306661 \cdot 661850419 
\\ &amp; \;\cdot 696183413 \cdot 737026033 \cdot 748888849 \cdot 764475661 \cdot 790916521 \cdot 1000657271 
\\ &amp; \;\cdot 1016247923 \cdot 1213865039 \cdot 2090081803 \cdot 3882107087 \cdot 4012893277 
\end{align*}\]

<p>Now we can solve the discrete log problem with <a href="https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm">Pohlig-Hellman</a> in time proportional to square root of the largest factor of \(p+1\). 
We need a basepoint, but we can just pick a random point (which is already in the code) and 
hope that it generates the group (it will likely be the case, we can restart if we fail).
Fortunately Sagemath had a generic version of discrete_log that implemented this, all we needed 
was to pass in:</p>

<ol>
  <li>The group operation - <code class="language-plaintext highlighter-rouge">G_add</code></li>
  <li>The identity element - \((1, 0)\)</li>
  <li>The inverse function -  <code class="language-plaintext highlighter-rouge">lambda x: G_mul(p, x)</code></li>
</ol>

<p>Unfortunately, somebody changed the sage library function at some point and made it not so 
generic. Took me a while to figure out why I kept getting python errors until I looked at
the source code and realized it didn’t even try to use the operations I passed in and instead
tried to use the <code class="language-plaintext highlighter-rouge">**</code> operation (I should submit a ticket and maybe try to submit a fix). 
Instead I searched elsewhere for a discrete_log method.
I went and modified the commented out <code class="language-plaintext highlighter-rouge">old_discrete_log</code> method I found in <a href="https://github.com/sagemath/sagelib/blob/master/sage/groups/generic.py">a super outdated version of the sage library</a> that
I stumbled across on Google. It worked!</p>

<h3 id="solving-the-modular-knapsack-problem">Solving the Modular Knapsack Problem</h3>
<p>Now we’re still not done yet, we had to solve the following problem (which I learned afterwards was called the Modular Knapsack Problem) where \(a, b, ..., e\) were known, and \(x_0, ... x_5\) were
numbers that were at most \(2^{64}\) (pretty small compared to \(p\)).</p>

\[a x_0 + b x_1 + c x_2 + d x_3 + e x_4 + f x_5 \equiv e \pmod{p+1}\]

<p>At first I thought you could choose a new generator to get a system of equations with different 
coefficients and use Gaussian elimination, but after implementing that I realized I was dumb.
Choosing a new generator would just multiply all the coefficients by a constant factor.</p>

<p>It was back to the drawing board for me
until Robert suggested to “use lattices” and had some code handy
that conveniently solved this exact problem 
(<a href="https://github.com/nneonneo/pwn-stuff/blob/master/math/solvelinmod.py">https://github.com/nneonneo/pwn-stuff/blob/master/math/solvelinmod.py</a>).</p>

<p>(I really should learn how <a href="https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm">LLL reduction</a> works at some point by trying to code it myself)</p>

<p>It worked perfectly and spat out the flag!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DUCTF{a_1337_hyp3rb0la_m33ts_th3_mult1pl3_DLP!!}
</code></pre></div></div>

<p>Complete sage solve script:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">solvelinmod</span>

<span class="k">def</span> <span class="nf">G_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">B</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span> <span class="o">+</span> <span class="n">D</span><span class="o">*</span><span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span> <span class="o">+</span> <span class="n">x2</span><span class="o">*</span><span class="n">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">G_mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">G_add</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">G_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">get_elem</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kronecker</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="n">d</span><span class="p">)))</span> <span class="o">*</span> <span class="n">inverse_mod</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">rand_element</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kronecker</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="n">d</span><span class="p">)))</span> <span class="o">*</span> <span class="n">inverse_mod</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_curve</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">D</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> <span class="o">==</span><span class="mi">0</span>

<span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G_mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 

<span class="n">D</span> <span class="o">=</span> <span class="mi">13337</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">17568142778435152362975498611159042138909402642078949814477371651322179417849164549408357464774644525711780515232117470272550677945089719112177956836141583</span>
<span class="n">G</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">8249149405495350491346934933585109414510787432598250096114687570379053133508711862485128035174547571919256235441699899388417666835599315963507480727674285</span><span class="p">,</span> <span class="mi">10151966144947987666795899106244951506314545969111450078363915090201899029695981970354886015549281568762501638756950135017679627954071369058817947706039379</span><span class="p">),</span> <span class="p">(</span><span class="mi">10148658254415475588279956574772196898575718154643967163626694400363009168529645860280959810873028393970853643723425023678857408220330929116526467295542507</span><span class="p">,</span> <span class="mi">3332426625916817700349475905733631656792492189677766534230576987725484499618918928882667666640821403823057239790395654518704427126712280655564669757208129</span><span class="p">),</span> <span class="p">(</span><span class="mi">1839326681086939925214853980855626023120414606039474419455499625885357274275815189399880356995376514021329118829062071144818562457268892324773839713533977</span><span class="p">,</span> <span class="mi">17502649671831125396398431215302241914145169143474764941575812028922929277656849105757332346628455059539582448544435155655055157181361580680672298566085040</span><span class="p">),</span> <span class="p">(</span><span class="mi">3165955958968203879237344349962533642598441044481692770147807839372942715856047580766073222297692574025922260374409920417665600069665162502514403188432579</span><span class="p">,</span> <span class="mi">9382092026348588885644924948782239369051861025018411316856012639637274661831713783735305424388410778778529413114167923397187236739639802371814632949741663</span><span class="p">),</span> <span class="p">(</span><span class="mi">8500294063291124527108623281980255870507549734362604259645984044370658620385351338711051998886026260657132944353675335178871934798200163035190278483491633</span><span class="p">,</span> <span class="mi">7641198814027309580920446604109217188703337221305342467525089149977505415741300885194767452232679123441594451455097533000754553745051816419202345186703390</span><span class="p">),</span> <span class="p">(</span><span class="mi">12352685673550986453697035560006632628194788902921398545668828437339873544223895997440585227838919968929669738393535610103382084842900404005432007637193943</span><span class="p">,</span> <span class="mi">2453949984320580417885537763124479618094084392655766673219227195157341323190069350175423869908524758510177197973709821798974003013596311361995273762475822</span><span class="p">)]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5388567167658786935158413401674168420144429277172064721472662913563775670320298461949979362402157764272762755236320989018989446360740720072488623102776015</span><span class="p">,</span> <span class="mi">7420389277336940268114831002964626027945367662485419944369852006741899961686908509331719915794976159062761271182318814519641566938538911041229521838799714</span><span class="p">)</span>

<span class="n">order</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span>

<span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="mi">4</span> <span class="p">,</span> <span class="mi">3</span><span class="o">**</span><span class="mi">3</span> <span class="p">,</span> <span class="mi">3271</span> <span class="p">,</span> <span class="mi">18119</span> <span class="p">,</span> <span class="mi">23857</span> <span class="p">,</span> <span class="mi">35923</span> <span class="p">,</span> <span class="mi">1505323</span> <span class="p">,</span> <span class="mi">3036643</span> <span class="p">,</span> <span class="mi">3878597</span> <span class="p">,</span> <span class="mi">7306661</span> <span class="p">,</span> <span class="mi">661850419</span> <span class="p">,</span> <span class="mi">696183413</span> <span class="p">,</span> <span class="mi">737026033</span> <span class="p">,</span> <span class="mi">748888849</span> <span class="p">,</span> <span class="mi">764475661</span> <span class="p">,</span> <span class="mi">790916521</span> <span class="p">,</span> <span class="mi">1000657271</span> <span class="p">,</span> <span class="mi">1016247923</span> <span class="p">,</span> <span class="mi">1213865039</span> <span class="p">,</span> <span class="mi">2090081803</span> <span class="p">,</span> <span class="mi">3882107087</span> <span class="p">,</span> <span class="mi">4012893277</span><span class="p">]</span>
<span class="k">assert</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="n">order</span><span class="p">)</span>

<span class="n">zero</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="n">multiplication_names</span> <span class="o">=</span> <span class="p">(</span> <span class="s">'multiplication'</span><span class="p">,</span> <span class="s">'times'</span><span class="p">,</span> <span class="s">'product'</span><span class="p">,</span> <span class="s">'*'</span><span class="p">)</span>
<span class="n">addition_names</span>       <span class="o">=</span> <span class="p">(</span> <span class="s">'addition'</span><span class="p">,</span> <span class="s">'plus'</span><span class="p">,</span> <span class="s">'sum'</span><span class="p">,</span> <span class="s">'+'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">old_discrete_log</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s">'*'</span><span class="p">,</span>
                          <span class="n">identity</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">base</span>

     <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">add</span>
     <span class="n">Z</span> <span class="o">=</span> <span class="n">Integers</span><span class="p">()</span>

     <span class="k">if</span> <span class="n">operation</span> <span class="ow">in</span> <span class="n">multiplication_names</span><span class="p">:</span>
         <span class="n">identity</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">parent</span><span class="p">()(</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">inverse</span>  <span class="o">=</span> <span class="n">inv</span>
         <span class="n">op</span> <span class="o">=</span> <span class="n">mul</span>
         <span class="k">if</span> <span class="nb">ord</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
             <span class="nb">ord</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">multiplicative_order</span><span class="p">()</span>
     <span class="k">elif</span> <span class="n">operation</span> <span class="ow">in</span> <span class="n">addition_names</span><span class="p">:</span>
         <span class="n">identity</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">parent</span><span class="p">()(</span><span class="mi">0</span><span class="p">)</span>
         <span class="n">inverse</span>  <span class="o">=</span> <span class="n">neg</span>
         <span class="n">op</span> <span class="o">=</span> <span class="n">add</span>
         <span class="k">if</span> <span class="nb">ord</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
             <span class="nb">ord</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">order</span><span class="p">()</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="k">if</span> <span class="nb">ord</span><span class="o">==</span><span class="bp">None</span> <span class="ow">or</span> <span class="n">identity</span><span class="o">==</span><span class="bp">None</span> <span class="ow">or</span> <span class="n">inverse</span><span class="o">==</span><span class="bp">None</span> <span class="ow">or</span> <span class="n">op</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
             <span class="k">print</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

     <span class="k">if</span> <span class="nb">ord</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
         <span class="n">c</span> <span class="o">=</span> <span class="n">identity</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">):</span>
             <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>        <span class="c1"># is b^i
</span>                 <span class="k">return</span> <span class="n">Z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
             <span class="n">c</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

     <span class="n">m</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">.</span><span class="n">isqrt</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>  <span class="c1"># we need sqrt(ord) rounded up
</span>     <span class="n">table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>     <span class="c1"># will hold pairs (b^j,j) for j in range(m)
</span>     <span class="n">g</span> <span class="o">=</span> <span class="n">identity</span>       <span class="c1"># will run through b**j    
</span>     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="n">g</span><span class="p">:</span>
             <span class="k">return</span> <span class="n">Z</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>           
         <span class="n">table</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
         <span class="n">g</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

     <span class="n">g</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>     <span class="c1"># this is now b**(-m)
</span>     <span class="n">h</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>        <span class="c1"># will run through a*g**i = a*b**(-i*m)
</span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
         <span class="n">j</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>  <span class="c1"># then a*b**(-i*m) == b**j
</span>             <span class="k">return</span> <span class="n">Z</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
             <span class="n">h</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">g</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d_log</span><span class="p">(</span><span class="n">q</span><span class="p">):</span> 
    <span class="k">print</span><span class="p">(</span><span class="s">"dlogging: "</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">dlogs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">order</span><span class="o">//</span><span class="n">f</span>
        <span class="n">qt</span> <span class="o">=</span> <span class="n">G_mul</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
        <span class="n">gent</span> <span class="o">=</span> <span class="n">G_mul</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">dlog</span> <span class="o">=</span> <span class="n">old_discrete_log</span><span class="p">(</span><span class="n">qt</span><span class="p">,</span> <span class="n">gent</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s">'NONE'</span><span class="p">,</span>
                            <span class="n">op</span><span class="o">=</span><span class="n">G_add</span><span class="p">,</span> <span class="n">identity</span><span class="o">=</span><span class="n">zero</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="n">inverse</span><span class="p">)</span>
        <span class="n">dlogs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">dlog</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">dlogs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"oh no"</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">CRT_list</span><span class="p">(</span><span class="n">dlogs</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l</span>

<span class="c1"># This one worked
</span><span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1306220711535023766817529329601851834684473168538006969205607217300581985606511824830746054324343087425816093230309507256982431519166958670991896717613121</span><span class="p">,</span> <span class="mi">2753498082952557748021507097242652783238834762442333661230349459126933713491167991334695072154480164453278454296466352910947274843516626885289923809047182</span><span class="p">)</span>
<span class="n">ords</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_log</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>
<span class="n">ordc</span> <span class="o">=</span> <span class="n">d_log</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x0'</span><span class="p">)</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x1'</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x2'</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x3'</span><span class="p">)</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x4'</span><span class="p">)</span>
<span class="n">x5</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s">'x5'</span><span class="p">)</span>
<span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">ords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x0</span> <span class="o">+</span> <span class="n">ords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span> <span class="o">+</span> <span class="n">ords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span> <span class="o">+</span> <span class="n">ords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">x3</span> <span class="o">+</span> <span class="n">ords</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">x4</span> <span class="o">+</span> <span class="n">ords</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">x5</span> <span class="o">==</span> <span class="n">ordc</span><span class="p">)</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="n">x0</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="n">x3</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="n">x4</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="n">x5</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">}</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">solvelinmod</span><span class="p">.</span><span class="n">solve_linear_mod</span><span class="p">([(</span><span class="n">eq</span><span class="p">,</span> <span class="n">order</span><span class="p">)],</span> <span class="n">bounds</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">sol</span> <span class="o">=</span> <span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">flag</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
    <span class="n">flag</span><span class="o">+=</span><span class="nb">int</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">key</span><span class="p">]).</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s">'big'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[[DUCTF 2021] yadlp]]></summary></entry><entry><title type="html">[CSAW CTF 2021] bits</title><link href="http://localhost:4000/2021/09/14/csawctf-bits.html" rel="alternate" type="text/html" title="[CSAW CTF 2021] bits" /><published>2021-09-14T00:00:00-05:00</published><updated>2021-09-14T00:00:00-05:00</updated><id>http://localhost:4000/2021/09/14/csawctf-bits</id><content type="html" xml:base="http://localhost:4000/2021/09/14/csawctf-bits.html"><![CDATA[<h1 id="csaw-ctf-2021-bits">[CSAW CTF 2021] bits</h1>

<h2 id="tldr">tl;dr</h2>

<p>The flag is encrypted with a password of \(a^d \pmod N\).
Decrypt by solving the discrete logarithm problem to compute \(d\) from \(g^d\pmod N\) 
and an oracle that given a number \(g^x \pmod n\) will return the 883rd bit of \(x\). 
Do the discrete log problem by factorizing \(N\) with the oracle by getting 
the top bits with a binary search, the lower bits by interactively querying the oracle
and doing some number theory to factorize and compute the discrete log.</p>

<h2 id="description">Description</h2>

<p>crypto/bits; 24 solves, 497 points
Challenge authors: <code class="language-plaintext highlighter-rouge">Robin_Jadoul</code> and <code class="language-plaintext highlighter-rouge">jack</code></p>

<p>I wrote this oracle in rust so that it can’t sue companies over java stuff.</p>

<p>nc crypto.chal.csaw.io 5010</p>

<p><a href="https://ctf.csaw.io/files/cae893c9c0f0d7b488b3eddb1b99219a/main.rs">main.rs</a></p>

<h2 id="solving-the-challenge">Solving the challenge</h2>

<p>Interacting with the oracle gives:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+++++++++++++++++++++++++++++++++++++++++++++++
+ I hear there's a mythical oracle at Delphi. +
+++++++++++++++++++++++++++++++++++++++++++++++

N = 1264774171500162520522740123707654912813731191511600716918716574718457223687306654609462735310087859826053230623347849924104479609383350278302774436797213741150063894250655073009487778309401701437562813695437500274843520937515731255706515213415007999907839388181535469916350256765596422669114523648082369
G = 2
publ = 1212487202243646984386173446511282289931417044351458340480622092138117454231970360918091810951525920616364982248466162290051013120417592308811316654798136079145284397900865487961920243710196032048995386251362920330926430559242059799715206708168895458603215715146064914454925425870564649600485121538888979
alice = 1024640601443471247332323755059540128989623988611561774565028170938628815764407641381833150460508942917290472170138094077448704053365256467287344121743320435086310199233461822424914222345675720038545559040111784145778223966348376549176125773372309112010889362453693591886310086077964503934892770669706366
nbits = 1006
FLAG = c19eb80cb79e8e15e854db731190f514405670c9fd686775c235905a70293808b0506b42d62398aabe55bb949db56edd0c
</code></pre></div></div>

<p>We can look at the code (all in rust) to explain some of this output.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">let</span> <span class="k">mut</span> <span class="n">rnd</span> <span class="o">=</span> <span class="nn">RandState</span><span class="p">::</span><span class="nf">new_custom</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">sysrng</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Integer</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">ORDER</span><span class="p">)</span><span class="nf">.random_below</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rnd</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">publ</span> <span class="o">=</span> <span class="nn">Integer</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">G</span><span class="p">)</span><span class="nf">.pow_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">N</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">nbits</span> <span class="o">=</span> <span class="n">ORDER</span><span class="nf">.significant_bits</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">alice</span> <span class="o">=</span> <span class="nn">Integer</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">G</span><span class="p">)</span><span class="nf">.pow_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Integer</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">ORDER</span><span class="p">)</span><span class="nf">.random_below</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rnd</span><span class="p">),</span> <span class="o">&amp;*</span><span class="n">N</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"N = {}</span><span class="se">\n</span><span class="s">G = {}</span><span class="se">\n</span><span class="s">publ = {}</span><span class="se">\n</span><span class="s">alice = {}</span><span class="se">\n</span><span class="s">nbits = {}"</span><span class="p">,</span>
        <span class="o">*</span><span class="n">N</span><span class="p">,</span>
        <span class="o">*</span><span class="n">G</span><span class="p">,</span>
        <span class="n">publ</span><span class="p">,</span>
        <span class="n">alice</span><span class="p">,</span>
        <span class="n">nbits</span><span class="p">);</span>
    <span class="nf">encrypt_flag</span><span class="p">(</span><span class="n">alice</span><span class="nf">.pow_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
</code></pre></div></div>
<p>Looking at <code class="language-plaintext highlighter-rouge">encrypt_flag()</code> we see:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">encrypt_flag</span><span class="p">(</span><span class="n">shared</span><span class="p">:</span> <span class="n">Integer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">hasher</span> <span class="o">=</span> <span class="nn">Sha256</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">hasher</span><span class="nf">.update</span><span class="p">(</span><span class="n">shared</span><span class="nf">.to_string</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">hasher</span><span class="nf">.finalize</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nn">Aes256Ctr</span><span class="p">::</span><span class="nf">from_block_cipher</span><span class="p">(</span>
        <span class="nn">Aes256</span><span class="p">::</span><span class="nf">new_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="nf">.as_slice</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="o">&amp;</span><span class="nn">GenericArray</span><span class="p">::</span><span class="nf">clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">16</span><span class="p">])</span>
        <span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">FLAG</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="n">cipher</span><span class="nf">.apply_keystream</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">flag</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"FLAG = {}"</span><span class="p">,</span> <span class="n">flag</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:02x}"</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The code is a bit difficult to understand to someone who has never done any rust, but
the gist of it is clear, the function takes in an integer, does some transformations,
than encrypts the flag with it. If we knew the password we should be able to easily
decrypt the function.</p>

<p>So it looks like <code class="language-plaintext highlighter-rouge">FLAG</code> is encrypted with <code class="language-plaintext highlighter-rouge">alice.pow_mod(d, N)</code>, and we are given <code class="language-plaintext highlighter-rouge">alice</code>,
so it is enough to figure out what <code class="language-plaintext highlighter-rouge">d</code> is.
We are given <code class="language-plaintext highlighter-rouge">publ = G.pow_mod(d, N)</code> and <code class="language-plaintext highlighter-rouge">G = 2</code>, so we need to solve the discrete log problem
to recover <code class="language-plaintext highlighter-rouge">d</code>. 
Normally this is very difficult without knowing the factorization of \(N\), but we also have access
to an oracle.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">match</span> <span class="nf">dlog</span><span class="p">(</span><span class="n">input</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"-1"</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="n">G</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.pow_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">N</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">==</span> <span class="n">input</span> <span class="o">%</span> <span class="o">&amp;*</span><span class="n">N</span><span class="p">);</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ORDER</span><span class="p">);</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="nf">.get_bit</span><span class="p">(</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">123</span><span class="p">)</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Checking <code class="language-plaintext highlighter-rouge">nbits=1006</code> we have that <code class="language-plaintext highlighter-rouge">nbits-123 = 883</code>.
So we have access to an oracle which given an integer \(m\), computes the discrete log base \(G\), 
the value \(x\) which solves \(G^x \equiv m\pmod{N}\),
then returns the 883rd bit of \(x\).</p>

<p>So if we send to the oracle \(2^y\pmod N\), the oracle will spit out the 883rd bit of
\(y\pmod{\texttt{ORDER}}\) where <code class="language-plaintext highlighter-rouge">ORDER</code> is the order of \(2\) in \(P\). 
If \(y&lt; \texttt{ORDER}\) this just gives us the 883rd bit, but if we query larger numbers,
we get the 883rd bit of \(y-k\cdot \texttt{ORDER}\) for some \(k\). 
Let’s denote \(m_k = k\cdot \texttt{ORDER}\).</p>

<p>Playing around with this, if the 883rd bit of \(m_k\) of \(1\),
but that bit is \(0\) for \(m_i\) with \(0\le i &lt; k\),
than we can actually find the exact value of the leading bits if 
we send queries with \(y\) having the last 883 bit be all \(1\)s.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="mi">883</span>
<span class="c1"># pad the last b bits with 1s
</span><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># do binary search for the most significant bits of 
</span><span class="n">hi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">124</span>
<span class="n">lo</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">123</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Binary searching for leading bits"</span><span class="p">)</span>
<span class="c1"># Technically I didn't verify that function is  0/1 in this range 
# (could have multiple flipping threshholds) but this works so ¯\_(ツ)_/¯
</span><span class="k">while</span> <span class="n">lo</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">query</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="o">==</span> <span class="sa">b</span><span class="s">'1'</span><span class="p">:</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>

<span class="k">assert</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">lo</span><span class="p">))</span><span class="o">!=</span><span class="n">query</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">hi</span><span class="p">)))</span>
</code></pre></div></div>

<p>At this point we have the highest bits, we want to recover the lower bits
Since now we have have a good estimate of \(m_k\) (call that \(y\)), 
we can get the next bit by querying for \(2y\),
which we’ll get a response of the 883rd bit of \(2y-2m_k\),
or equivalently the 882nd bit of \(m_k\). This way we can recover the lower bits
of \(m_k\).</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># At this point, leading bits is hi, we should search for next bits 
</span><span class="n">hi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">query</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">hi</span><span class="p">))</span> <span class="o">==</span> <span class="sa">b</span><span class="s">'0'</span><span class="p">:</span> <span class="c1"># bit is 0
</span>        <span class="n">hi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">hi</span>
</code></pre></div></div>

<p>From here, we can guess that \(m_1 = \texttt{ORDER}\) is \(\phi(N)/2\),
and use that to compute the factorization of \(N\) into \(p\) and \(q\).</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ok at this point, hi is k*phi/? where ? is 2 or 3, guess ? = 2
</span><span class="n">qs</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">+</span><span class="n">N</span><span class="o">//</span><span class="n">qs</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="n">qs</span><span class="p">)</span> 
<span class="c1"># this should give approximately what we were looking for, round up because N &gt; qs
</span><span class="k">assert</span><span class="p">(</span><span class="n">hi</span><span class="o">%</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> 
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span><span class="o">//</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">qs</span>

<span class="c1"># integer sqrt
</span><span class="k">def</span> <span class="nf">_sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">while</span> <span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">mid</span><span class="o">*</span><span class="n">mid</span> <span class="o">&lt;=</span><span class="n">n</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">return</span> <span class="n">lo</span> 
<span class="c1"># use solution from 
# https://crypto.stackexchange.com/questions/5791/why-is-it-important-that-phin-is-kept-a-secret-in-rsa
</span><span class="n">pplusq</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">phi</span><span class="o">+</span><span class="mi">1</span>
<span class="n">pminq</span> <span class="o">=</span> <span class="n">_sqrt</span><span class="p">(</span><span class="n">pplusq</span><span class="o">*</span><span class="n">pplusq</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">pminq</span><span class="o">*</span><span class="n">pminq</span><span class="o">==</span><span class="n">pplusq</span><span class="o">*</span><span class="n">pplusq</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">pplusq</span> <span class="o">+</span> <span class="n">pminq</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pplusq</span> <span class="o">-</span> <span class="n">q</span>
<span class="k">assert</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">==</span><span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</code></pre></div></div>

<p>This gives us the factorization! Now we can run the following sage code and use CRT to compute the discrete log of <code class="language-plaintext highlighter-rouge">publ</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Note now we have G, N = p*q
# We need to calculate x s.t. G^x == publ (mod N)
</span>
<span class="n">publ</span> <span class="o">=</span> <span class="mi">1212487202243646984386173446511282289931417044351458340480622092138117454231970360918091810951525920616364982248466162290051013120417592308811316654798136079145284397900865487961920243710196032048995386251362920330926430559242059799715206708168895458603215715146064914454925425870564649600485121538888979</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">26713395582018967511973684657814004241261156269415358729692119332394978760010789226380713422950849602617267772456438810738143011486768190080495256375003</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">47346065295850807479811692397225726348630781686943994678601678975909956314423885777086052944991365707991632035242429229693774362516043822438274496319123</span>
<span class="c1"># Calculate G^x_1 == publ (mod p)
</span><span class="n">x_1</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="n">p</span><span class="p">).</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Calculate G^x_2 == publ (mod q)
</span><span class="n">x_2</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="n">q</span><span class="p">).</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># =&gt; x = x_1 (mod p-1), x = x_2 (mod q-1)
</span><span class="n">x</span> <span class="o">=</span> <span class="n">crt</span><span class="p">([</span><span class="n">x_1</span><span class="p">,</span> <span class="n">x_2</span><span class="p">],</span>  <span class="p">[</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Now that we have <code class="language-plaintext highlighter-rouge">d</code> all we need to do is decrypt it in rust:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">decrypt_flag</span><span class="p">(</span><span class="n">shared</span><span class="p">:</span> <span class="n">Integer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">hasher</span> <span class="o">=</span> <span class="nn">Sha256</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">hasher</span><span class="nf">.update</span><span class="p">(</span><span class="n">shared</span><span class="nf">.to_string</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">hasher</span><span class="nf">.finalize</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nn">Aes256Ctr</span><span class="p">::</span><span class="nf">from_block_cipher</span><span class="p">(</span>
        <span class="nn">Aes256</span><span class="p">::</span><span class="nf">new_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="nf">.as_slice</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="o">&amp;</span><span class="nn">GenericArray</span><span class="p">::</span><span class="nf">clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">16</span><span class="p">]),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">flag</span> <span class="o">=</span> <span class="s">b"&gt;</span><span class="se">\x0f\x13\x1c\x12</span><span class="s">3</span><span class="se">\xe6\xbf\xcc</span><span class="s">C</span><span class="se">\xf5</span><span class="s">*,bfs</span><span class="se">\x19</span><span class="s">}</span><span class="se">\xb5</span><span class="s">{</span><span class="se">\x1f\x05\xa7\xe3\xca</span><span class="s">E</span><span class="se">\xed</span><span class="s">h</span><span class="se">\xef\x07\x99\xed</span><span class="s">@</span><span class="se">\xf1</span><span class="s">BL</span><span class="se">\xb1</span><span class="s">Y</span><span class="se">\xb7\xca</span><span class="s">Hg</span><span class="se">\xdc\xc2</span><span class="s">'</span><span class="se">\x93\xdf\xcc\x8a</span><span class="s">"</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="n">cipher</span><span class="nf">.apply_keystream</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">flag</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"FLAG = {}"</span><span class="p">,</span>
        <span class="n">flag</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span> <span class="k">as</span> <span class="nb">char</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>And by calling <code class="language-plaintext highlighter-rouge">decrypt_flag(alice.pow_mod(&amp;d, &amp;N).unwrap());</code> we get our flag!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FLAG = flag{https://www.youtube.com/watch?v=uhTCeZasCmc}
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[[CSAW CTF 2021] bits]]></summary></entry><entry><title type="html">[CSAW CTF 2021] forgery</title><link href="http://localhost:4000/2021/09/14/csawctf-forgery.html" rel="alternate" type="text/html" title="[CSAW CTF 2021] forgery" /><published>2021-09-14T00:00:00-05:00</published><updated>2021-09-14T00:00:00-05:00</updated><id>http://localhost:4000/2021/09/14/csawctf-forgery</id><content type="html" xml:base="http://localhost:4000/2021/09/14/csawctf-forgery.html"><![CDATA[<h1 id="csaw-ctf-2021-forgery">[CSAW CTF 2021] forgery</h1>

<h2 id="tldr">tl;dr</h2>

<p>The server asks for one of three strings but must be signed correctly using the
<a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm">Digital Signiture Algorithm</a> (DSA)
with prime \(p\).
Only the lower 1024 bits of input matter so we can fake a message by using number theory and hide the message in higher order bits.</p>

<h2 id="description">Description</h2>

<p>crypto/bits; 127 solves, 405 points</p>

<p>Felicity and Cisco would like to hire you as an intern for a new security company that they are forming. They have given you a black box signature verification system to test out and see if you can forge a signature. Forge it and you will get a passphrase to be hired!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc crypto.chal.csaw.io 5006
</code></pre></div></div>

<p><a href="https://ctf.csaw.io/files/1f5a0b563b3d325a219db045d856bf5e/forgery.py">forgery.py</a></p>

<h2 id="solving-the-challenge">Solving the challenge</h2>

<p>We first notice that the code verifies our triple (answer, \(r\), \(s\)), before
checking if certain strings appear as a substring as our answer.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">elif</span> <span class="n">verify</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">if</span> <span class="sa">b</span><span class="s">'Felicity'</span> <span class="ow">in</span> <span class="n">answer_bytes</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"I see you are a fan of Arrow!"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="sa">b</span><span class="s">'Cisco'</span> <span class="ow">in</span> <span class="n">answer_bytes</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"I see you are a fan of Flash!"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Brown noser!"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>
<p>Furthermore a mask of the lower 1024 bits is defined and only that is verified against \(r\) and \(s\).</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MASK</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span>

<span class="p">...</span>

<span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">answer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK</span> 
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]]):</span> <span class="c1">#hrm s = 0 or -1 is ez
</span>        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="o">%</span> <span class="n">p</span>
</code></pre></div></div>

<p>So we can choose any message \(m\) of up 1024 bits, hide our substring in the upper bits, and come up with an \(r\) and \(s\) that satisfies:</p>

\[g^m \equiv y^r r^s \pmod p\]

<p>Furthermore, none of our choices of \(m, r, s\) can be equal to \(0\) or \(p-1\), which would easily and trivially satisfy the equation.
However we can choose the next best thing, \(m = r = s = \frac{p-1}{2}\). 
By basic number theory, any number to the power of \(\frac{p-1}{2}\) is either \(1\) or \(-1\)
mod \(p\), and these numbers are distributed essentially randomly (not really but for our purposes
they are).</p>

<p>So with a \(50\%\) chance this choice will work!</p>

<p>Solve script:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">def</span> <span class="nf">read_until</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="sa">b</span><span class="s">':'</span><span class="p">):</span>
    <span class="n">delim</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">delim</span><span class="p">,</span> <span class="s">"ascii"</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">buf</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">delim</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buf</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="s">"crypto.chal.csaw.io"</span><span class="p">,</span><span class="mi">5006</span><span class="p">)</span>
<span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">':'</span><span class="p">)</span>
<span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">' '</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">' '</span><span class="p">).</span><span class="n">strip</span><span class="p">())</span>
<span class="n">g</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">' '</span><span class="p">).</span><span class="n">strip</span><span class="p">())</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">).</span><span class="n">strip</span><span class="p">())</span>

<span class="n">phi</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span>
<span class="n">fake</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
<span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'both'</span><span class="o">+</span> <span class="n">l2b</span><span class="p">(</span><span class="n">fake</span><span class="p">)</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">b2l</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">fake</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">fake</span>

<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="nb">hex</span><span class="p">(),</span> <span class="s">'ascii'</span><span class="p">))</span>
<span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="nb">hex</span><span class="p">(),</span> <span class="s">'ascii'</span><span class="p">))</span>
<span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">sock</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">))</span>
</code></pre></div></div>

<p>Flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag{7h3_4rr0wv3r53_15_4w350M3!}
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[[CSAW CTF 2021] forgery]]></summary></entry><entry><title type="html">[corCTF 2021] smogofwar</title><link href="http://localhost:4000/2021/08/25/corctf-smogofwar.html" rel="alternate" type="text/html" title="[corCTF 2021] smogofwar" /><published>2021-08-25T00:00:00-05:00</published><updated>2021-08-25T00:00:00-05:00</updated><id>http://localhost:4000/2021/08/25/corctf-smogofwar</id><content type="html" xml:base="http://localhost:4000/2021/08/25/corctf-smogofwar.html"><![CDATA[<h1 id="corctf-2021-smogofwar">[corCTF 2021] smogofwar</h1>

<h2 id="tldr">tl;dr</h2>

<p>Beat a chess bot in “Smog of War” a variant of chess (almost?) identical to the
<a href="https://en.wikipedia.org/wiki/Dark_chess">Fog of War</a> variation of chess by sending two different moves to the server.</p>

<h2 id="description">Description</h2>

<p>misc/smogofwar; 7 solves , 497 points
Challenge author: <code class="language-plaintext highlighter-rouge">strellic</code></p>

<p>Hey, I made a chess website to play my favorite variant, smog of war!
Why don’t you check it out and play against my AI. He has some nasty surprises,
but if you beat him I’ll give you a flag.. good luck :)</p>

<p><a href="https://smogofwar.be.ax">https://smogofwar.be.ax</a></p>

<p>You’re also given a zip file named <code class="language-plaintext highlighter-rouge">smogofwar.zip</code> that presumably has the
contents of the website and the server that handles the chess game.</p>

<h2 id="the-writeup">The writeup</h2>

<p>See writeup I wrote at <a href="https://ubcctf.github.io/2021/08/corctf-smogofwar/">https://ubcctf.github.io/2021/08/corctf-smogofwar/</a>.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[[corCTF 2021] smogofwar]]></summary></entry></feed>